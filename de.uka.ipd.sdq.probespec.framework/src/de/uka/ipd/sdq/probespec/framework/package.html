<html>
<body>
The ProbeSpecification framework is the counterpart of the ProbeSpecification ECore metamodel. It allows the definition of measuring points to be used by performance analysis frameworks. Below it is assumed that performance analyses are conducted using a simulation framework like SimuCom.
By means of ProbeSpecification models virtually arbitrary (ECore based) software architecture models can be enriched by measuring points. A measuring point identifies the type of measurement as well as the model element getting measured. The simulation code can be generated by a M2T transformation like depicted below. Within the simulation code this framework is applied in order to take the measurements.

<img src="doc-files/architektur.png" width="750">
<p>
As mentioned above this framework can be adopted to other simulation frameworks (like SimuCom in the picture) by using a specialized {@link de.uka.ipd.sdq.probespec.framework.probes.AProbeStrategyFactory}. This Factory implements methods how to take a measure and then uses the probe spec framework to process and store the results.

<h3>Concepts</h3>
<h4>Probe</h4>
A probe describes <b>what</b> should be measured. Examples are the waiting time for a resource and the current (simulated) time.
<p>Notice that there are no Probes on the framework level. Within the framework a Probe is represented by ProbeSamples. The ProbeSample class encapsulates an atomic measurement of a particular type.
<h4>ProbeSet</h4>
A ProbeSet contains several Probes and defines the point <b>where</b> the sample is taken.
<p>
<b>Notice</b> that there are no ProbeSets on the framework level. Within the framework a ProbeSet is represented by ProbeSetSamples. The ProbeSetSample class encapsulates several ProbeSamples. Thus the ProbeSetSample represents a set of various measurements [taken simultaneously] for the same model element. Afterwards it is added to a blackboard which stores all ProbeSetSamples.
<h4>Calculator</h4>
<p>A Calculator is responsible for <strong>calculating the result</strong> from one or more measurements taken at different positions. This concept is motivated by the measurement of response times. In order to measure the response time of a service call it is necessary to take measurements at two different positions: When the service is called and when the service is finished. For this purpose at each position a ProbeSet gets mounted that measures the current time. The calculator gets notified of measurements originating from these ProbeSets (these measurements are called ProbeSetSamples) and calculates the response time when both samples have arrived.</p>
<p>The notification is conducted by means of the observer pattern. Each time when a new ProbeSetSample is added to the blackboard the Calculator gets notified. Then they combine ProbeSetSamples (e.g. calculates the difference) or select the needed ProbeSamples from the ProbeSetSample. Afterwards they combine these information to a so called result tuple and pass it to the Pipes-and-Filters chain.
A Calculator also adds semantic information to the result tuple. E.g. a ResponseTimeCalculator holds describing information about the result tuple (e.g. description, name, scale,...). Without this information this Calculator would just return an undescribed time difference. </p>
<p>In certain cases the ProbeSetSample is already the result where no further calculation is desired. Here some kind of pass-through Calculator should be used.</p>
<h3>Transformation</h3>
<table border="1">
	<tr><th>Model Element</th><th>Related Framework Class</th><th>Representation of the Result</th></tr>

	<tr><td>Probe</td><td>-</td><td>ProbeSample</td></tr>
	<tr><td>ProbeSet</td><td>-</td><td>ProbeSetSample</td></tr>
	<tr><td>Calculator</td><td>Calculator</td><td>PipeData</td></tr>
</table>

<h3>Example Transformation</h3>
Here we make the assumption that the Pipes-and-Filters transformation is already done and the references to the needed PipeAndFiltersManagers are available. To see how this transformation is done see the package documentation of the pipesandfilters package.

The code which has to be generated by the transformation can be divided into two parts:
<h4>1. Framework initialization code</h4>

This code will be executed only once when the simulation is started. First the SampleBlackboard and the correct ProbeStrategyFactory must be created. These references have to be globally available, so that they can be accessed from anywhere within the simulation code.
The next part of the initialization code creates instances for all Calculators which are modeled in the Probe Specification model. The constructor for each Calculator takes the blackboard reference (and then registers as an observer automatically) and the entity IDs of the ProbeSets belonging to this Calculator.
Afterwards the {@link de.uka.ipd.sdq.pipesandfilters.PipesAndFiltersManager} must be set for each Calculator so that the Calculator can pass the result tuples to the corresponding Pipes-and-Filters chain.

<pre>
{@code
1	blackboard = new SampleBlackboard();
2	factory = new MyProbeStrategyFactory();
3
	[do for all Calculators]
4		calc = new MyCalculator(blackboard, "ProbeSet1_ID", "ProbeSet2_ID");
5		calc.setPipesAndFiltersManager(manager);
	[loop]
}
</pre>

<h4>2. Code which is scattered in the simulation code</h4>

The second part of the transformation generates code which is placed in the simulation code. So the correct ProbeSetSamples can be taken and added to the blackboard.
<p>
The steps that need to be done are shown in the example below. The example takes a CurrentTimeProbe and a CPUStateProbe.
<p>
In line 1 a Vector has to be created which will contains all ProbeSamples.
<p>
Then (line 2-3) the needed measurements are taken - here CurrentTime and CPUState - and added to the vector. The first argument is the ID of the probe entity in the model. The other arguments have to be passed depending on the concrete implementation of the probe strategy. For example if the CPUState should be measured a reference to the CPU resource might have to be passed.
<p>
In line 4 the ProbeSetSample is created using the ProbeSample vector, a requestContextID and the ID of the ProbeSet entity in the model.
<p>
If the ProbeSetSample represents a start ProbeSet for a binary Calculator (e.g. ResponseTimeCalculator, WaitingTimeCalculator) the TimeToLive for this ProbeSetSample must be increased, so that it remains in the SampleBlackboard (See the {@link de.uka.ipd.sdq.probespec.framework.SampleBlackboard} and {@link de.uka.ipd.sdq.probespec.framework.ProbeSetSample} documentation for further information).
<p>
Finally (line 6) the ProbeSetSample is added to the SampleBlackboard and then forwarded to the Calculators by the observer pattern.

<pre>
{@code
[...Simulation Code]
 1    Vector<ProbeSample<?, ? extends Quantity>> psv1 = new Vector<ProbeSample<?, ?
           extends Quantity>>();
 2    psv1.add(factory.getTakeCurrentTime().takeSample("probeID1", [...]));
 3    psv1.add(factory.getTakeCPUState().takeSample("probeID2", [...]));
 4    ProbeSetSample pss1 = new ProbeSetSample(psv1, requestContextID, "modelElementID", "ProbeSetID1");
 5    pss1.addToTimeToLive(1);
 6    blackboard.addProbeSetSample(pss1)
[...Simulation Code]
}
</pre>

</body>
</html>