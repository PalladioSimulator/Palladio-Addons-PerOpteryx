import OperationSignatureRegistry;
import EventChannelMiddlewareRegistry;
import SEFFUtil;
import InterfaceUtil;
import Commons;
import Source;
import SourcePort;
import SourceCommunication;
import EventDistribution;
import EventFilter;
import SinkCommunication;
import SinkPort;
import Sink;

modeltype PCM_ALLOC uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Allocation/5.0';
modeltype PCM_REP uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Repository/5.0';
modeltype PCM_SEFF uses 'http://sdq.ipd.uka.de/PalladioComponentModel/SEFF/5.0';
modeltype PCM_SYS uses 'http://sdq.ipd.uka.de/PalladioComponentModel/System/5.0';
modeltype PCM_RES_ENV uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceEnvironment/5.0';
modeltype PCM_RES_TYPE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceType/5.0';
modeltype PCM_USAGE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/UsageModel/5.0';
modeltype PCM_FEATURE_CONF uses 'http://sdq.ipd.uka.de/FeatureConfig/2.0';
modeltype PCM_FEATURE_MOD uses 'http://sdq.ipd.uka.de/FeatureModel/2.0';
modeltype PCM_CORE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/5.0';
modeltype PCM_COMP uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/Composition/5.0';
modeltype PCM_ENTITY uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/Entity/5.0';
modeltype PCM_PARAM uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Parameter/5.0';
modeltype PCM_STOEX uses 'http://sdq.ipd.uka.de/StochasticExpressions/1.0';


/**
 * Transformation of the event specific elements to classic
 * PCM elements that are supported by the simulation engine.
 *
 * This is a platform specific transformation taking a middleware repository
 * into account to weave-in the platform specific properties.
 *
 * The weaving is done by
 * - take an additional repository model
 * - Look-up middleware interfaces by their names
 * - Check the resource environment for a server named Middleware
 * - Instantiate the components of the middleware repository 
 *   on the source, middleware or respectivly on the sink server 
 *
 * There are two alternatives for connections between event sources and sinks.
 * 1. Direct Connector
 * 2. Through an explicit event channel
 * To handle this, as a priliminary step, an instance of the middleware is deployed 
 * for each event channel and registered for it.
 * Later on, when the event sources are processed, the sources are processed according
 * whether they are connected through a direct vonnevtor or an event channel.
 *
 *
 * @author Benjamin Klatt
 */
transformation events2ClassicPCM(	inout pcmAllocation : PCM_ALLOC,
									inout pcmSystem : PCM_SYS,
									inout pcmRepository : PCM_REP,
									in middlewareRepository : PCM_REP);


/** The central distribution role if one exists */
property centralSourceCommunicationRole : OperationProvidedRole = null;
/** The central distribution assembly context if one exists */
property centralSourceCommunicationContext : AssemblyContext = null;
/** The central event distribution role if one exists */
property centralEventDistributionRole : OperationProvidedRole = null;
/** The central event distribution assembly context if one exists */
property centralEventDistributionContext : AssemblyContext = null;
/** The central event Sender role if one exists */
property centralSenderRole : OperationProvidedRole = null;
/** The central event Sender assembly context if one exists */
property centralSenderContext : AssemblyContext = null;

/**
 * The main transformation.
 * This is the entry point to the overall transformation
 */
main() {
	
	log('Event-Transformation started');
	
	createOperationInterfaces();

	var eventChannelAllocations := Finder_findAllEventChannelAllocations(pcmAllocation);
	eventChannelAllocations->forEach(channelAllocation){
		setupEventChannelMiddleware(channelAllocation.eventChannel__AllocationContext,
									channelAllocation.resourceContainer_AllocationContext, 
									middlewareRepository);
	};

	setupCentralMiddleware(middlewareRepository);
		
	Finder_findAllAssemblyContextsWithSourceRoles(pcmAllocation)->forEach(assContext){
		Finder_findAllSourceRoles(assContext)->forEach(sourceRole){
			processSourceRole(sourceRole,assContext);
		};
	};
	
	removeEventModelElements();
}






// --------------------------------------------------------------------------
// ModelUtil Operations
//
// The eclipse QVTo implementation does not allow
// to place those methods in an external library.
// This is because of the necessary access to the model
// instead of a model element
// --------------------------------------------------------------------------

/**
 * Create an operation interface for each EventGroup in the processed model.
 */
helper createOperationInterfaces() {
	var eventGroups : Set(EventGroup) = Finder_findAllEventGroups(pcmAllocation);
	eventGroups->forEach(eventGroup){
		InterfaceUtil_createOperationInterface(eventGroup);
	};	
}

/**
 * Setup the middleware instances for an event channel
 * and register it in the EventChannelMiddlewareRegistry.
 *
 * @param eventChannel The event channel to setup the middleware for.
 * @param channelResourceContainer The resource container the event channel instance is deployed on.
 * @param mwRepository The middleware repository.
 */
helper setupEventChannelMiddleware(	in eventChannel: EventChannel,
									in channelResourceContainer : ResourceContainer, 
									in mwRepository : PCM_REP){

	// check for a central middleware container and deploy middleware if required
	log('Setup Middleware for EventChannel '+eventChannel.entityName);
		
	// Lookup for components providing the middleware
	// interfaces and check how many components are used to provide
	// those interfaces.
	
		
	// Get the necessary enviromnent infos
	var system : System = Finder_findSystem(pcmAllocation);
	var allocation : Allocation = Finder_findAllocation(pcmAllocation);
		
	// variables to store the identified components for later comparision
	var channelSourceCommunicationComponent : RepositoryComponent = null;
	var channelEventDistributionComponent : RepositoryComponent = null;
	var channelSenderComponent : RepositoryComponent = null;
	var channelSourceCommunicationContext : AssemblyContext = null;
	var channelEventDistributionContext : AssemblyContext = null;
	var channelSenderContext : AssemblyContext = null;
	
	
		
	// lookup SourceCommunication
	var channelSourceCommunicationRole := Finder_findOperationProvidedRole('IMiddlewareSourceCommunication',mwRepository);
	if(channelSourceCommunicationRole <> null)
	then {
		channelSourceCommunicationComponent := Commons_getProvidingComponent(channelSourceCommunicationRole);
	} endif;

	// lookup EventDistribution		
	var channelEventDistributionRole := Finder_findOperationProvidedRole('IMiddlewareEventDistribution',mwRepository);
	if(channelEventDistributionRole <> null)
	then {
		channelEventDistributionComponent := Commons_getProvidingComponent(channelEventDistributionRole);
	} endif;

	// lookup EventDistribution		
	var channelSenderRole := Finder_findOperationProvidedRole('IMiddlewareFilter',mwRepository);
	if(channelSenderRole <> null)
	then {
		channelSenderComponent := Commons_getProvidingComponent(channelSenderRole);
	} endif;
		
		
	// Deploy the central middleware components
	if(channelSourceCommunicationComponent != null)
	then {
		channelSourceCommunicationContext := Commons_createAssemblyContext(	channelSourceCommunicationComponent, 
																				system,
																				Set{}, 
																				system,
																				allocation,
																				channelResourceContainer);
	} endif;	
	
	// if a seperate component provides the event distribution role, deploy this
	// otherwise, if the sender implementing component is the same as one of the
	// others, point the according reference to it
	if(channelEventDistributionComponent <> channelSourceCommunicationComponent and channelEventDistributionComponent != null)
	then {
		channelEventDistributionContext := Commons_createAssemblyContext(	channelEventDistributionComponent, 
																			system,
																			Set{}, 
																			system,
																			allocation,
																			channelResourceContainer);
	} endif;
	if (channelEventDistributionComponent = channelSourceCommunicationComponent) // the elif construct is not yet supported by eclipse qvto 
	then {
		channelEventDistributionContext := channelSourceCommunicationContext;
	} endif;		
		
		
	// if a seperate component provides the event sender role, deploy this
	// otherwise, if the sender implementing component is the same as one of the
	// others, point the according reference to it
	if((channelSenderComponent != null) 
			and(channelSenderComponent <> channelSourceCommunicationComponent) 
			and (channelSenderComponent <> channelEventDistributionComponent))
	then {
		channelSenderContext := Commons_createAssemblyContext(	channelSenderComponent, 
																system,
																Set{}, 
																system,
																allocation,
																channelResourceContainer);
	} endif;
	if (channelSenderComponent = channelSourceCommunicationComponent) // the elif construct is not yet supported by eclipse qvto 
	then {
		channelSenderContext := channelSourceCommunicationContext;
	} endif;		
	if (channelSenderComponent = channelEventDistributionComponent) // the elif construct is not yet supported by eclipse qvto 
	then {
		channelEventDistributionContext := channelEventDistributionContext;
	} endif;	
	
	EventChannelMiddlewareRegistry_register(	eventChannel,
												channelSourceCommunicationContext,
												channelEventDistributionContext,
												channelSenderContext);
}

/**
 * Setup the central middleware if required.
 * This method cans the used resource enviroment for a 
 * resourcecontainer named Middleware. if this is in place,
 * the middleware components related to this central hub are 
 * deployed in this resource container.
 *
 * @param repository The middleware repository.
 */
helper setupCentralMiddleware(repository : PCM_REP){

	// check for a central middleware container and deploy middleware if required
	var centralMiddlewareContainer		:= Finder_findMiddlewareContainer(pcmAllocation);
	if(centralMiddlewareContainer <> null)
	then {
		log('Central Middleware Container detected.');
		log('Deploy according components.');
		
		// Lookup for components providing the middleware
		// interfaces and check how many components are used to provide
		// those interfaces.
		
		// Get the necessary enviromnent infos
		var system : System = Finder_findSystem(pcmAllocation);
		var allocation : Allocation = Finder_findAllocation(pcmAllocation);
		
		// variables to store the identified components for later comparision
		var SourceCommunicationComponent : RepositoryComponent = null;
		var eventDistributionComponent : RepositoryComponent = null;
		var senderComponent : RepositoryComponent = null;
		
		// lookup SourceCommunication
		centralSourceCommunicationRole := Finder_findOperationProvidedRole('IMiddlewareSourceCommunication',repository);
		if(centralSourceCommunicationRole <> null)
		then {
			SourceCommunicationComponent := Commons_getProvidingComponent(centralSourceCommunicationRole);
		} endif;

		// lookup EventDistribution		
		centralEventDistributionRole := Finder_findOperationProvidedRole('IMiddlewareEventDistribution',repository);
		if(centralEventDistributionRole <> null)
		then {
			eventDistributionComponent := Commons_getProvidingComponent(centralEventDistributionRole);
		} endif;

		// lookup EventDistribution		
		centralSenderRole := Finder_findOperationProvidedRole('IMiddlewareFilter',repository);
		if(centralSenderRole <> null)
		then {
			senderComponent := Commons_getProvidingComponent(centralSenderRole);
		} endif;
		
		
		// Deploy the central middleware components
		if(SourceCommunicationComponent != null)
		then {
			centralSourceCommunicationContext := Commons_createAssemblyContext(	SourceCommunicationComponent, 
																					system,
																					Set{}, 
																					system,
																					allocation,
																					centralMiddlewareContainer);
		} endif;	
		
		// if a seperate component provides the event distribution role, deploy this
		// otherwise, if the sender implementing component is the same as one of the
		// others, point the according reference to it
		if(eventDistributionComponent <> SourceCommunicationComponent and eventDistributionComponent != null)
		then {
			centralEventDistributionContext := Commons_createAssemblyContext(	eventDistributionComponent, 
																				system,
																				Set{}, 
																				system,
																				allocation,
																				centralMiddlewareContainer);
		} endif;
		if (eventDistributionComponent = SourceCommunicationComponent) // the elif construct is not yet supported by eclipse qvto 
		then {
			centralEventDistributionContext := centralSourceCommunicationContext;
		} endif;		
		
		
		// if a seperate component provides the event sender role, deploy this
		// otherwise, if the sender implementing component is the same as one of the
		// others, point the according reference to it
		if((senderComponent != null) 
				and(senderComponent <> SourceCommunicationComponent) 
				and (senderComponent <> eventDistributionComponent))
		then {
			centralSenderContext := Commons_createAssemblyContext(	senderComponent, 
																	system,
																	Set{}, 
																	system,
																	allocation,
																	centralMiddlewareContainer);
		} endif;
		if (senderComponent = SourceCommunicationComponent) // the elif construct is not yet supported by eclipse qvto 
		then {
			centralSenderContext := centralSourceCommunicationContext;
		} endif;		
		if (senderComponent = eventDistributionComponent) // the elif construct is not yet supported by eclipse qvto 
		then {
			centralEventDistributionContext := centralEventDistributionContext;
		} endif;		
		
		
	} 
	endif;
}

/**
 * Process the transformation for a source role.
 *
 * @param sourceRole The source Role to process
 */
helper processSourceRole(sourceRole : SourceRole, sourceAssemblyContext : AssemblyContext){
	
	log ('-----------------------------------------');
	log ('Process Source: ' + sourceRole.entityName);

	// check if direct connectors exist for this source role and process them
	var eventConnectors : Set(AssemblyEventConnector) = Finder_findAssemblyEventConnectors(sourceRole, pcmAllocation, sourceAssemblyContext);
	if(eventConnectors->size() > 0)
	then {
		processSourceRoleDirectConnection(	sourceRole,
											sourceAssemblyContext,
											eventConnectors);
	} endif;
	
	
	var eventChannelConnectors : Set(EventChannelSourceConnector) = Finder_findEventChannelSourceConnectors(sourceRole, pcmAllocation,sourceAssemblyContext);
	if(eventChannelConnectors->size() > 0)
	then {
		eventChannelConnectors->forEach(connector) {
			processSourceRoleChannelConnection(	sourceRole,
												sourceAssemblyContext,
												connector);
		};
	} endif;
	
	return;
}


/**
 * Process the direct event connections of a source role.
 *
 * @param sourceRole The source role to process.
 * @param sourceAssemblyContext The assembly the source belongs to.
 * @param eventConnectors The assembly event connectors of this role to be processed.
 */
helper 	processSourceRoleChannelConnection(sourceRole : SourceRole,
											sourceAssemblyContext : AssemblyContext,
											eventChannelConnector: EventChannelSourceConnector){
 	
 	log("Build the channel connection");
 	
	// find the environment elements to be set
	var system 			: System = Finder_findSystem(pcmAllocation);
	var allocation		: Allocation = Finder_findAllocation(sourceAssemblyContext, pcmAllocation);
	var eventChannel 	: EventChannel = eventChannelConnector.eventChannel__EventChannelSourceConnector;

	// lookup resource container
	var resourceContainerSource 		:= Finder_findResourceContainer(sourceAssemblyContext,pcmAllocation);
	var eventChannelMiddleware 			:= EventChannelMiddlewareRegistry_find(eventChannelConnector.eventChannel__EventChannelSourceConnector);
	var resourceContainerEventChannel 	:= Finder_findResourceContainer(	eventChannel, 
																		pcmAllocation);	
		
	//---------------------------		
	// Adopt the Source Component
	//---------------------------		
	log ('Adopt Source');
	// build operation roles for the source		
	// get the matching operation interface for the source role
	var interface : OperationInterface = findOperationInterface(sourceRole)->any(true);
	var sourceComponentOperationRequiredRole := map Commons_createOperationRequiredRole(interface,sourceRole);

	// we are processing the roles not the assembly contexts so it 
	// can happen that an assembly context is not connected if 
	// the same component is deployed twice
	// change emit event to external call actions that point to the current source role
	var actions : Set(EmitEventAction) = pcmRepository.objectsOfType(EmitEventAction)->select(e | e.sourceRole__EmitEventAction = sourceRole);
	Source_transformEmitEventActions(sourceRole, sourceComponentOperationRequiredRole,actions);
	// remove the emit EmitEventActions while they do not need to be 
	// modified in the next run again
	//actions->forEach(element){
	//	pcmRepository.removeElement(element);		
	//};
		
	// references to middleware components to handle if they provide 
	// more than one middleware interface
	var sourcePortMWComponent : RepositoryComponent = null;
	var SourceCommunicationMWComponent : RepositoryComponent = null;

	//---------------------------		
	// Build Source Port
	//---------------------------
	log ('Build Source Port');
		
	// create the source port component
	var sourcePortAssemblyContext := SourcePort_create(	sourceRole,
														sourceComponentOperationRequiredRole,
														system,
														allocation,
														resourceContainerSource,
														sourceAssemblyContext);

	// connect to middleware
	var sourcePortMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																	'IMiddlewareSourcePort',
																	sourcePortAssemblyContext,
																	null,
																	Set{},
																	middlewareRepository,
																	system,
																	allocation,
																	resourceContainerSource);						
							
															
	//------------------------------		
	// Build SourceCommunication
	//------------------------------
	log ('Build Source Communication');
													
	// get the role to connect with
	var sourcePortRequiredRole := Commons_getOperationRequiredRole(sourcePortAssemblyContext,interface);
	
	// create the source port component
	var SourceCommunicationAssemblyContext := SourceCommunication_create(	sourceRole,
														sourcePortRequiredRole,
														system,
														allocation,
														OrderedSet{resourceContainerEventChannel},
														sourcePortAssemblyContext);															

	// connect to middleware
	var SourceCommunicationMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																				'IMiddlewareSourceCommunication',
																				SourceCommunicationAssemblyContext,
																				eventChannelMiddleware.channelSourceCommunicationContext,
																				Set{sourcePortMWContext},
																				middlewareRepository,
																				system,
																				allocation,
																				resourceContainerSource);


															
	//------------------------------		
	// Build Event Distribution
	//------------------------------
	log ('Build Event Distribution');
													
	// get the role to connect with
	var SourceCommunicationRequiredRole := Commons_getOperationRequiredRole(SourceCommunicationAssemblyContext,interface);
	
	// create the source port component
	var eventDistributionAssemblyContext := EventDistribution_create(	sourceRole,
														SourceCommunicationRequiredRole,
														system,
														allocation,
														OrderedSet{resourceContainerEventChannel},
														SourceCommunicationAssemblyContext);														

	// connect to middleware
	log("**************************************");
	log("weave in event distribution middleware");
	var eventDistributionMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																		'IMiddlewareEventDistribution',
																		eventDistributionAssemblyContext,
																		eventChannelMiddleware.channelEventDistributionContext,
																		Set{sourcePortMWContext,SourceCommunicationMWContext},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSource);
	log("**************************************");

		//------------------------------		
		// Build All Sink Connections
		//------------------------------
		var eventChannelSinkConnectors := eventChannel.eventChannelSinkConnector__EventChannel;
		log('Build Event Channel Sink Connectors : ', eventChannelSinkConnectors->size());
		var existingfilterMWContext : AssemblyContext := null;
		
		eventChannelSinkConnectors->forEach(connector){
			
			var sinkRole := connector.sinkRole__EventChannelSinkConnector;
			var sinkAssemblyContext 	:= connector.assemblyContext__EventChannelSinkConnector;
			var resourceContainerSink	 := Finder_findResourceContainer(sinkAssemblyContext,pcmAllocation);
			
			var filterCondition := connector.filterCondition__EventChannelSinkConnector;
			
			//-------------------------------------		
			// Add Connection to Event Distribution
			//-------------------------------------		
			var eventDistributionRequiredRole := EventDistribution_addSinkRequiredRole(eventDistributionAssemblyContext,interface);
			
			//------------------------------		
			// Build EventFilter
			//------------------------------
			log ('Build Event Filter');
															
			
			// create the event sender component
			var EventFilterAssemblyContext := EventFilter_create(	sourceRole,
																	sinkRole,
																	eventDistributionRequiredRole,
																	system,
																	allocation,
																	OrderedSet{resourceContainerEventChannel},
																	eventDistributionAssemblyContext,
																	filterCondition);														

			// connect to middleware
			var filterMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																		'IMiddlewareFilter',
																		EventFilterAssemblyContext,
																		eventChannelMiddleware.channelSenderContext,
																		Set{sourcePortMWContext,SourceCommunicationMWContext,eventDistributionMWContext,existingfilterMWContext},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSource);
			existingfilterMWContext := filterMWContext;
			
			// get the role to connect with
			var EventFilterRequiredRole := Commons_getOperationRequiredRole(EventFilterAssemblyContext,interface);
			
			//------------------------------		
			// Build SinkCommunication
			//------------------------------
			log ('Build Sink Communication');
															
			
			// create the event sender component
			var SinkCommunicationAssemblyContext := SinkCommunication_create(	sourceRole,
																		sinkRole,
																		EventFilterRequiredRole,
																		system,
																		allocation,
																		resourceContainerEventChannel,
																		EventFilterAssemblyContext);														

			// connect to middleware
			var SinkCommunicationMWContext := Transformation_weaveInMiddleware(	sinkAssemblyContext,
																		'IMiddlewareSinkCommunication',
																		SinkCommunicationAssemblyContext,
																		null,
																		Set{},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerEventChannel);															
			
			// get the role to connect with
			var SinkCommunicationRequiredRole := Commons_getOperationRequiredRole(SinkCommunicationAssemblyContext,interface);
	
	
			//------------------------------		
			// Build Sink Port
			//------------------------------
			log ('Build Sink Port');
															
			
			// create the event sender component
			var sinkPortAssemblyContext := SinkPort_create(	sourceRole,
															sinkRole,
															SinkCommunicationRequiredRole,
															system,
															allocation,
															resourceContainerSink,
															SinkCommunicationAssemblyContext);														

			// connect to middleware
			var sinkPortMWContext := Transformation_weaveInMiddleware(	sinkAssemblyContext,
																		'IMiddlewareSinkPort',
																		sinkPortAssemblyContext,
																		null,
																		Set{SinkCommunicationMWContext},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSink);															
			
			// get the role to connect with
			var sinkPortRequiredRole := Commons_getOperationRequiredRole(sinkPortAssemblyContext,interface);
			
			
			//---------------------------		
			// Adopt Sink Component
			//---------------------------		
			Sink_adoptAndConnect(	sinkPortAssemblyContext,
									sinkPortRequiredRole,
									connector,
									system);
		}
}

/**
 * Process the direct event connections of a source role.
 *
 * @param sourceRole The source role to process.
 * @param sourceAssemblyContext The assembly the source belongs to.
 * @param eventConnectors The assembly event connectors of this role to be processed.
 */
helper 	processSourceRoleDirectConnection(sourceRole : SourceRole,
											sourceAssemblyContext : AssemblyContext,
											eventConnectors: Set(AssemblyEventConnector)){
		// find the environment elements to be set
		var system 					: System = Finder_findSystem(pcmAllocation);
		var allocation 				:= Finder_findAllocation(sourceAssemblyContext, pcmAllocation);

		// lookup resource container
		var resourceContainerSource 		:= Finder_findResourceContainer(sourceAssemblyContext,pcmAllocation);
		var resourceContainerMiddleware		:= Finder_findMiddlewareContainer(pcmAllocation);
		
		
		//---------------------------		
		// Adopt the Source Component
		//---------------------------		
		log ('Adopt Source');
		// build operation roles for the source		
		// get the matching operation interface for the source role
		var interface : OperationInterface = findOperationInterface(sourceRole)->any(true);
		var sourceComponentOperationRequiredRole := map Commons_createOperationRequiredRole(interface,sourceRole);

// we are procssing the roles not the assembly contexts so it 
// can happen that an assembly context is not connected if 
// the same component is deployed twice
		// change emit event to external call actions that point to the current source role
		var actions : Set(EmitEventAction) = pcmRepository.objectsOfType(EmitEventAction)->select(e | e.sourceRole__EmitEventAction = sourceRole);
		Source_transformEmitEventActions(sourceRole, sourceComponentOperationRequiredRole,actions);
		// remove the emit EmitEventActions while they do not need to be 
		// modified in the next run again
		//actions->forEach(element){
		//	pcmRepository.removeElement(element);		
		//};
		
		// references to detect the number of different components
		var sourcePortMWComponent : RepositoryComponent = null;
		var SourceCommunicationMWComponent : RepositoryComponent = null;

		//---------------------------		
		// Build Source Port
		//---------------------------
		log ('Build Source Port');
			
		// create the source port component
		var sourcePortAssemblyContext := SourcePort_create(	sourceRole,
															sourceComponentOperationRequiredRole,
															system,
															allocation,
															resourceContainerSource,
															sourceAssemblyContext);

		// connect to middleware
		var sourcePortMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																		'IMiddlewareSourcePort',
																		sourcePortAssemblyContext,
																		null,
																		Set{},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSource);						
							
							
															
		//------------------------------		
		// Build SourceCommunication
		//------------------------------
		log ('Build Source Communication');
														
		// get the role to connect with
		var sourcePortRequiredRole := Commons_getOperationRequiredRole(sourcePortAssemblyContext,interface);
		
		// create the source port component
		var SourceCommunicationAssemblyContext := SourceCommunication_create(	sourceRole,
															sourcePortRequiredRole,
															system,
															allocation,
															OrderedSet{resourceContainerMiddleware,resourceContainerSource},
															sourcePortAssemblyContext);															

		// connect to middleware
		var SourceCommunicationMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																					'IMiddlewareSourceCommunication',
																					SourceCommunicationAssemblyContext,
																					centralSourceCommunicationContext,
																					Set{sourcePortMWContext},
																					middlewareRepository,
																					system,
																					allocation,
																					resourceContainerSource);


															
		//------------------------------		
		// Build Event Distribution
		//------------------------------
		log ('Build Event Distribution');
														
		// get the role to connect with
		var SourceCommunicationRequiredRole := Commons_getOperationRequiredRole(SourceCommunicationAssemblyContext,interface);
		
		// create the source port component
		var eventDistributionAssemblyContext := EventDistribution_create(	sourceRole,
															SourceCommunicationRequiredRole,
															system,
															allocation,
															OrderedSet{resourceContainerMiddleware,resourceContainerSource},
															SourceCommunicationAssemblyContext);														

		// connect to middleware
		var eventDistributionMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																			'IMiddlewareEventDistribution',
																			eventDistributionAssemblyContext,
																			centralEventDistributionContext,
																			Set{sourcePortMWContext,SourceCommunicationMWContext},
																			middlewareRepository,
																			system,
																			allocation,
																			resourceContainerSource);

		//------------------------------		
		// Build All Sink Connections
		//------------------------------
		log('Build Event Connectors : ', eventConnectors->size());
		var existingfilterMWContext : AssemblyContext := null;
		
		eventConnectors->forEach(connector){
			
			var sinkRole := connector.sinkRole__AssemblyEventConnector;
			var sinkAssemblyContext 	:= connector.sinkAssemblyContext__AssemblyEventConnector;
			var resourceContainerSink	 := Finder_findResourceContainer(sinkAssemblyContext,pcmAllocation);
			
	  		var filterCondition := connector.filterCondition__AssemblyEventConnector;
			
			//-------------------------------------		
			// Add Connection to Event Distribution
			//-------------------------------------		
			var eventDistributionRequiredRole := EventDistribution_addSinkRequiredRole(eventDistributionAssemblyContext,interface);
			
			//------------------------------		
			// Build EventFilter
			//------------------------------
			log ('Build Event Sender');
															
			
			// create the event sender component
			var EventFilterAssemblyContext := EventFilter_create(	sourceRole,
																	sinkRole,
																	eventDistributionRequiredRole,
																	system,
																	allocation,
																	OrderedSet{resourceContainerMiddleware,resourceContainerSource},
																	eventDistributionAssemblyContext,
																	filterCondition);														

			// connect to middleware
			var filterMWContext := Transformation_weaveInMiddleware(	sourceAssemblyContext,
																		'IMiddlewareFilter',
																		EventFilterAssemblyContext,
																		centralSenderContext,
																		Set{sourcePortMWContext,SourceCommunicationMWContext,eventDistributionMWContext,existingfilterMWContext},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSource);
			existingfilterMWContext := filterMWContext;
			
			// get the role to connect with
			var EventFilterRequiredRole := Commons_getOperationRequiredRole(EventFilterAssemblyContext,interface);
			
			//------------------------------		
			// Build SinkCommunication
			//------------------------------
			log ('Build Event Receiver');
															
			
			// create the event sender component
			var SinkCommunicationAssemblyContext := SinkCommunication_create(	sourceRole,
																		sinkRole,
																		EventFilterRequiredRole,
																		system,
																		allocation,
																		resourceContainerSink,
																		EventFilterAssemblyContext);														

			// connect to middleware
			var SinkCommunicationMWContext := Transformation_weaveInMiddleware(	sinkAssemblyContext,
																		'IMiddlewareSinkCommunication',
																		SinkCommunicationAssemblyContext,
																		null,
																		Set{},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSink);															
			
			// get the role to connect with
			var SinkCommunicationRequiredRole := Commons_getOperationRequiredRole(SinkCommunicationAssemblyContext,interface);
	
	
			//------------------------------		
			// Build Sink Port
			//------------------------------
			log ('Build Sink Port');
															
			
			// create the event sender component
			var sinkPortAssemblyContext := SinkPort_create(	sourceRole,
															sinkRole,
															SinkCommunicationRequiredRole,
															system,
															allocation,
															resourceContainerSink,
															SinkCommunicationAssemblyContext);														

			// connect to middleware
			var sinkPortMWContext := Transformation_weaveInMiddleware(	sinkAssemblyContext,
																		'IMiddlewareSinkPort',
																		sinkPortAssemblyContext,
																		null,
																		Set{SinkCommunicationMWContext},
																		middlewareRepository,
																		system,
																		allocation,
																		resourceContainerSink);															
			
			// get the role to connect with
			var sinkPortRequiredRole := Commons_getOperationRequiredRole(sinkPortAssemblyContext,interface);
			
			
			//---------------------------		
			// Adopt Sink Component
			//---------------------------		
			Sink_adoptAndConnect(	sinkPortAssemblyContext,
									sinkPortRequiredRole,
									connector,
									system);
		}
}


/**
 * Remove all obsolete elements from the model
 */
helper removeEventModelElements(){
	
	// delete the emit event actions
	pcmRepository.objectsOfType(EmitEventAction)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the sources
	pcmRepository.objectsOfType(SourceRole)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the sinks
	pcmRepository.objectsOfType(SinkRole)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the assembly event channels
	pcmSystem.objectsOfType(EventChannel)->forEach(element){
		pcmSystem.removeElement(element);
	};
	
	// delete the assembly event channels
	var eventChannelAllocations := Finder_findAllEventChannelAllocations(pcmAllocation);
	eventChannelAllocations->forEach(element){
		pcmSystem.removeElement(element);
	};
	
	// delete the assembly event channel connectors
	pcmSystem.objectsOfType(EventChannelSourceConnector)->forEach(element){
		pcmSystem.removeElement(element);
	};
	pcmSystem.objectsOfType(EventChannelSinkConnector)->forEach(element){
		pcmSystem.removeElement(element);
	};
	
	// delete the assembly event connectors
	pcmSystem.objectsOfType(AssemblyEventConnector)->forEach(element){
		pcmSystem.removeElement(element);
	};
	
	// delete the assembly event types
	pcmRepository.objectsOfType(EventType)->forEach(element){
		pcmSystem.removeElement(element);
	};
	
	// delete the assembly event groups
	pcmRepository.objectsOfType(EventGroup)->forEach(element){
		pcmSystem.removeElement(element);
	}
}





// --------------------------------------------------------------------------
// Finder Operations
//
// Queries to locate specific elements in 
// the processed models
//
// The eclipse QVTo implementation does not allow
// to place those methods in an external library.
// This seems to be because of the necessary access to the model
// instead of a model element
// --------------------------------------------------------------------------


/**
 * Collect all event groups of the source roles of components deployed in an allocation.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified event groups.
 */
query Finder_findAllEventGroups(in allocationModel : PCM_ALLOC) : Set(EventGroup){

	// init the source set
	var eventGroups : Set(EventGroup) = Set{};

	var sources : Set(SourceRole) = Finder_findAllSourceRoles(allocationModel);
	sources->forEach(sourceRole){
		eventGroups += sourceRole.eventGroup__SourceRole;
	};

	// return the source set
	return eventGroups;
}


/**
 * Collect all EventChannels deployed in an allocation model.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified event channels.
 */
query Finder_findAllEventChannelAllocations(in allocationModel : PCM_ALLOC) : Set(AllocationContext){

	// init the source set
	var channelAllocContexts : Set(AllocationContext) = Set{};
	
	// iterate over all allocations and assemblies to collect the event channels
	allocationModel.objects()[Allocation]->forEach(allocation){
		allocation.allocationContexts_Allocation->forEach(allocContext){
			allocContext.eventChannel__AllocationContext->forEach(eventChannel){
				if(channelAllocContexts->select(s|s.id = allocContext.id)->size() = 0)
				then {
					channelAllocContexts += allocContext.oclAsType(AllocationContext);
				} endif;
			};
		};
	};
		
	// return the channel allocation context set
	return channelAllocContexts;
}


/**
 * Collect all AssemblyContexts deployed in an allocation model.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified AllocationContexts refering to an AssemblyContext.
 */
query Finder_findAllAssemblyAllocations(in allocationModel : PCM_ALLOC) : Set(AllocationContext){

	// init the source set
	var assemblyAllocContexts : Set(AllocationContext) = Set{};
	
	// iterate over all allocations and assemblies to collect the event channels
	allocationModel.objects()[Allocation]->forEach(allocation){
		allocation.allocationContexts_Allocation->forEach(allocContext){
			allocContext.assemblyContext_AllocationContext->forEach(assembly){
				if(assemblyAllocContexts->select(s|s.id = allocContext.id)->size() = 0)
				then {
					assemblyAllocContexts += allocContext.oclAsType(AllocationContext);
				} endif;
			};
		};
	};
		
	// return the channel allocation context set
	return assemblyAllocContexts;
}


/**
 * Collect all SourceRoles of the components deployed in an allocation model.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified source roles.
 */
query Finder_findAllSourceRoles(in allocationModel : PCM_ALLOC) : Set(SourceRole){

	// init the source set
	var sources : Set(SourceRole) = Set{};
	
	// iterate over all allocations and assemblies to collect the sources
	allocationModel.objects()[Allocation]->forEach(allocation){
		allocation.allocationContexts_Allocation->forEach(allocContext){
			allocContext.assemblyContext_AllocationContext->forEach(assContext){
				assContext.encapsulatedComponent__AssemblyContext.requiredRoles_InterfaceRequiringEntity->select(sr|sr.oclIsTypeOf(SourceRole))->forEach(role){
					if(sources->select(s|s.id = role.id)->size() = 0)
					then {
						sources += role.oclAsType(SourceRole);
					} endif;
				};
			};
		};
	};
		
	// return the source set
	return sources;
}


/**
 * Collect all SourceRoles of the components deployed in an allocation model.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified source roles.
 */
query Finder_findAllSourceRoles(in assemblyContext : AssemblyContext) : Bag(SourceRole){
	return assemblyContext.encapsulatedComponent__AssemblyContext
			.requiredRoles_InterfaceRequiringEntity
			->select(sr|sr.oclIsTypeOf(SourceRole))->oclAsType(SourceRole);
}


/**
 * Collect all SourceRoles of the components deployed in an allocation model.
 *
 * @param allocationModel The allocation model to scan.
 * @return The set of identified source roles.
 */
query Finder_findAllAssemblyContextsWithSourceRoles(in allocationModel : PCM_ALLOC) : Set(AssemblyContext){

	// init the source set
	var contexts : Set(AssemblyContext) = Set{};
	
	// iterate over all allocations and assemblies to collect the sources
	allocationModel.objects()[Allocation]->forEach(allocation){
		allocation.allocationContexts_Allocation->forEach(allocContext){
			allocContext.assemblyContext_AllocationContext->forEach(assContext){
				var sourceRoles := Finder_findAllSourceRoles(assContext);
				if(sourceRoles->size() > 0)
				then {
					contexts += assContext;
				} endif;
			};
		};
	};
		
	// return the source set
	return contexts;
}

/**
 * Find all assembly event connectors connected to a source.
 
 * @param	sourceRole		The source role the connectors have to be linked with
 * @param	allocationModel	The model to search in
 * @return	The set of matching event connectors
 */
query Finder_findAssemblyEventConnectors(	in sourceRole : SourceRole, 
											in allocationModel : PCM_ALLOC,
											in sourceContext : AssemblyContext ) : Set(AssemblyEventConnector){

	// init the source set
	var connectors : Set(Connector) = Set{};
	var eventconnectors : Set(AssemblyEventConnector) = Set{};
	// iterate over all allocations and assemblies to 
	// collect the assembly event connectors
	allocationModel.objects()[Allocation]->forEach(allocation){
		connectors += allocation.system_Allocation.connectors__ComposedStructure->select(oclIsTypeOf(AssemblyEventConnector));
	  
	};
	
	//Cast the connectors to EventConnectors
	connectors->forEach(con){	
			eventconnectors+=con->oclAsType(AssemblyEventConnector);
	};
	
	//Filter the eventconnectors, to include only connectors to this source role.								
	eventconnectors:=eventconnectors->select(c | c.sourceRole__AssemblyEventConnector.id = sourceRole.id
										and c.sourceAssemblyContext__AssemblyEventConnector = sourceContext);

	return eventconnectors;
}

/**
 * Find all assembly event connectors connected to a source.
 
 * @param	sourceRole		The source role the connectors have to be linked with
 * @param	allocationModel	The model to search in
 * @return	The set of matching event connectors
 */
query Finder_findEventChannelSourceConnectors(	in sourceRole : SourceRole, 
												in allocationModel : PCM_ALLOC,
												in sourceContext : AssemblyContext ) : Set(EventChannelSourceConnector){

	log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	// init the source set
	var connectors : Set(Connector) = Set{};
	var eventConnectors : Set(EventChannelSourceConnector) = Set{};
	// iterate over all allocations and assemblies to 
	// collect the event channel sink connectors
	allocationModel.objects()[Allocation]->forEach(allocation){
		connectors += allocation
							.system_Allocation
							.connectors__ComposedStructure
							->select(oclIsTypeOf(EventChannelSourceConnector));
	};

	log("Event Connector candidates found for Source "+sourceRole.entityName + " : "+connectors->size().toString());
	
	//Cast the connectors to EventConnectors
	connectors->forEach(con){	
			eventConnectors+=con->oclAsType(EventChannelSourceConnector);
	};
	
	eventConnectors->forEach(candidate){
		log("Candidate: assembly "+candidate.assemblyContext__EventChannelSourceConnector.id + 
						" source : "+candidate.sourceRole__EventChannelSourceRole.id+ 
						"| Searched assembly : "+sourceContext.id+ 
						" source : "+sourceRole.id);
	};
	
	//Filter the eventconnectors, to include only connectors to this source role.	
	eventConnectors := eventConnectors->select( c | c.sourceRole__EventChannelSourceRole.id = sourceRole.id
									and c.assemblyContext__EventChannelSourceConnector.id = sourceContext.id);

	log("Event Connectors found for Source "+sourceRole.entityName + " : "+eventConnectors->size().toString());
	log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

	return eventConnectors;
}

/**
 * Find the system linked by a pcm allocation model
 * @param allocationModel The allocation model to search in
 * @return The found system 
 */
query Finder_findSystem(in allocationModel : PCM_ALLOC) : System {
	
	var system := allocationModel.objects()[Allocation]
								.system_Allocation->any(true);
	return system;
}

/**
 * Find the central pcm allocation element.
 *
 * @param allocationModel The allocation model to search in
 * @return The found system 
 */
query Finder_findAllocation(in allocationModel : PCM_ALLOC) : Allocation {
	
	var allocation := allocationModel
								.objects()[Allocation]
								->any(true);
	return allocation;
}

/**
 * Find the ressource container for an assembly context.
 *
 * @param assemblyContext The assembly context to use as search parameter
 * @return The associated allocation
 */
query Finder_findAllocation(in assemblyContext : AssemblyContext, in allocationModel : PCM_ALLOC) : Allocation {
	
	var allocation : Allocation = null;
	
	allocation := allocationModel.objects()[Allocation]
						->select(a | a.allocationContexts_Allocation
									->select(ac | ac.assemblyContext_AllocationContext!=null)
									->select(ac | ac.assemblyContext_AllocationContext.id = assemblyContext.id)->size() > 0)
						->any(true);
	return allocation;
}


/**
 * Find the resource container for an assembly context.
 
 * @param assemblyContext The assembly context to use as search parameter
 * @return The associated ressource container
 */
query Finder_findResourceContainer(in assemblyContext : AssemblyContext, in allocationModel : PCM_ALLOC) : ResourceContainer {
	log("Start looking for AllocContext of an AssemblyContext: "+assemblyContext.entityName);
	var container : ResourceContainer = null;
	
	
	var allocContext : AllocationContext =Finder_findAllAssemblyAllocations(allocationModel)->select(ac | ac.assemblyContext_AllocationContext.id = assemblyContext.id)
						->any(true);
	log("found AllocContext"+allocContext.entityName+"referencing Container: "+ allocContext.resourceContainer_AllocationContext.entityName);
	container := allocContext.resourceContainer_AllocationContext;
	
	return container;
}


/**
 * Find the resource container for an assembly context.
 
 * @param assemblyContext The assembly context to use as search parameter
 * @return The associated ressource container
 */
query Finder_findResourceContainer(in eventChannel : EventChannel, in allocationModel : PCM_ALLOC) : ResourceContainer {
	log("Start looking fpr EventChannel Allo0cation");
	var container : ResourceContainer = null;
	
	var allocContext : AllocationContext = Finder_findAllEventChannelAllocations(allocationModel)->select(ac | ac.eventChannel__AllocationContext.id = eventChannel.id)
						->any(true);
	log("found AllocContext"+allocContext.entityName+"referencing Container: "+ allocContext.resourceContainer_AllocationContext.entityName);
	container := allocContext.resourceContainer_AllocationContext;
	
	return container;
}


/**
 * Find the resource container for the middleware.
 * This is done by a naming lookup "Middleware". 
 * If none is found, the source resource container is returned.
 *
 * @param assemblyContext The assembly context for the fall back resource container.
 * @param allocationModel The allocation model to lookup the resource container.
 * @return The associated ressource container
 */
query Finder_findMiddlewareContainer(in allocationModel : PCM_ALLOC) : ResourceContainer {
	
	// try to find a specific middleware container
	var container : ResourceContainer = allocationModel.objects()[Allocation]
										.targetResourceEnvironment_Allocation
										.resourceContainer_ResourceEnvironment
										->select(rc | rc.entityName = 'Middleware')
										->any(true);
		
	// return the selected container
	return container;
}

/**
 * Find an OperationProvidedRole for an interface with a specified name.
 * @param interfaceName The name of the interface that should be provided.
 * @param repository	The repository to search in.
 * @return The matching provided role or null if none was found.
 */
query Finder_findOperationProvidedRole(	in interfaceName : String , 
										in repository : PCM_REP) : OperationProvidedRole {
	
	var role := repository.objects()->select(o | o.oclIsTypeOf(OperationProvidedRole))
						->oclAsType(OperationProvidedRole)
						->select(opr | opr.providedInterface__OperationProvidedRole.entityName = interfaceName)
						->any(true);
	return role;
}

















// --------------------------------------------------------------------------
// Operations with explicit target model access
//
// The operations placed in this sections require to specify the explicit 
// target model to write to. 
//
// --------------------------------------------------------------------------




/**
 * Connect a plattform independent component to a middleware component.
 * This includes the creation of the required role for the pim component, 
 * the external call actions in the SEFFs and the connector between the 
 * the pim and the middleware contexts.
 *
 * @param  fromAssemblyContext 	The context of the pim component to connect from.
 * @param  toAssemblyContext 	The context of the middleware component to connect to.
 * @param  providedRole 		The provided middleware role to connect with.
 * @param  parentStructure 		The composed structure the connector should be placed in.
 * @return The new operation required role of the pim component.
 */
helper Transformation_connectComponentToMiddleware(	fromAssemblyContext : AssemblyContext,
													toAssemblyContext : AssemblyContext,
													providedRole : OperationProvidedRole,
													inout parentStructure : ComposedStructure) : OperationRequiredRole {
													
		// create required role
		var interface : OperationInterface = providedRole.providedInterface__OperationProvidedRole;
		var mwSignature : OperationSignature = interface.signatures__OperationInterface->any(true); // assumed there is only one
		var mwParameter : Parameter = mwSignature.parameters__OperationSignature->any(true); // assume there is only one
		var roleName : String = 'OperationRequiredRole' + interface.entityName + Commons_getUniqueElementNameSuffix();
		var component : BasicComponent = fromAssemblyContext.encapsulatedComponent__AssemblyContext[BasicComponent]->any(true); 

		
		var requiredRole : OperationRequiredRole = Commons_createOperationRequiredRole(	roleName,
																						component, 
																						interface);
		
		
		// create external call in all seffs of source context (assume only on parameter in the according signature)
		component.serviceEffectSpecifications__BasicComponent->forEach(seff){
			var rdSeff : ResourceDemandingSEFF = seff[ResourceDemandingSEFF]->any(true);
			var seffSignature : OperationSignature =  seff.describedService__SEFF[OperationSignature]->any(true);
			var eventParameter : Parameter = seffSignature.parameters__OperationSignature->any(true); // assumed only one event description as parameter
			
			var action : ExternalCallAction = SEFFUtil_addExternalCallActionToSeff(	rdSeff,
													mwSignature,
													requiredRole);
			var variableUsage : VariableUsage = Transformation_createVariableUsage(eventParameter,mwParameter, action);
			action.inputVariableUsages__CallAction := Set {variableUsage};
		};
		
		// create a connector between the source and the target contexts
		var assemblyConnector := Commons_connect(	fromAssemblyContext,
													toAssemblyContext,
													providedRole,
													requiredRole);
		return requiredRole;									
}

/**
 * Weave in a middleware component for a specific interface identified by it's name.
 *
 * Based on a communication context, it is ensured that a middleware component is created only once  
 * for an original component.
 *
 * @param communicationContext			The context of the platform independent communication participant this middleware is about.
 * @param interfaceName 				The name of the middleware interface to connect.
 * @param pimComponentContext 			The plattform independent component to weave in the middleware.
 * @param centralMiddlewareContext 		The central middleware component if one exist (otherwise null).
 * @param predecessorMiddlewareContexts The predecessor middleware contexts to check for the required interface (may be empty set)
 * @param middlewareRepository 			The middleware repository to weave in.
 * @param system						The system to place the component in.
 * @param allocation					The allocation model to place the allocation context in.
 * @param resourceContainer				The resourceContainer to deploy the new component on if there is no central one.
 * @return The middleware context that was weaved in or null if none.
 */
helper Transformation_weaveInMiddleware(	communicationContext : AssemblyContext,
											interfaceName : String,
											pimComponentContext : AssemblyContext,
											centralMiddlewareContext: AssemblyContext,
											predecessorMiddlewareContexts : Set(AssemblyContext),
											mwRepository : PCM_REP,
											system : System,
											allocation : Allocation,
											resourceContainer : ResourceContainer) : AssemblyContext {
	
	var middlewareContext : AssemblyContext = null;

	var middlewareRole : OperationProvidedRole = Finder_findOperationProvidedRole(interfaceName,mwRepository);
	if(middlewareRole <> null)
	then {
		
		log ('Weave in ' + interfaceName);
		
		
		// check central middleware
		if(centralMiddlewareContext <> null)
		then {
			log('connect with central middleware');		
			middlewareContext := centralMiddlewareContext;
		} 
		// work with local component
		else {	

			// check predecessor contexts of their component
			// also provides the currently required middleware interface
			predecessorMiddlewareContexts->forEach(predContext){
				if(middlewareContext = null
					and middlewareRole.providingEntity_ProvidedRole = predContext.encapsulatedComponent__AssemblyContext)
				then {
					log('connect with predecessor middleware');		
					middlewareContext := predContext;
				} endif;
			};		

			// if no context found yet deploy a new local one
			if(middlewareContext = null)
			then {
				log('deploy local middleware component for '+interfaceName);
				var mwComponent : RepositoryComponent = Commons_getProvidingComponent(middlewareRole);
				middlewareContext := map Commons_createAssemblyContext(	communicationContext,
																		mwComponent, 
																		system,
																		Set{}, 
																		system,
																		allocation,
																		resourceContainer);
				log('middleware context to use: ',middlewareContext);
			} endif;
		} endif;

		// connect the pim component with the middleware
		if(middlewareContext <> null)
		then {
			Transformation_connectComponentToMiddleware(	pimComponentContext,
															middlewareContext,
															middlewareRole,
															system);
		} endif;																
					
	} endif;
	// return the middleware context that was weaved in
	return middlewareContext;
}
	
/**
 * Create variable usage with a characterisation forward for all 
 * available characterization types. The referenced output parameter and the 
 * input parameter to read the characterisations are specified seperatly.
 *
 *
 * @param inputParam 	The parameter to get the characterizations from
 * @param outputParam 	The parameter to be referenced by the variable usage
 * @return The set of variable usages
 */
helper Transformation_createVariableUsage(	inputParameter : Parameter, 
											outputParameter : Parameter,
											action : CallAction ) : VariableUsage {
	var variableReference : VariableReference = VariableUtil_createVariableReference(outputParameter);
	// prepare the list of characterizations to set
	var characterizations : Set(VariableCharacterisation) = Set{};
	Commons_getListOfVariableCharacterisationTypes()->forEach(type){
		var characterisation := VariableUtil_createVariableCharacterisation(inputParameter,type);
		characterizations+= characterisation;
	};
	
	// create the variable usage
	var usage : VariableUsage = object VariableUsage @ pcmRepository {
		namedReference__VariableUsage := variableReference;
		variableCharacterisation_VariableUsage := characterizations;
		callAction__VariableUsage = action;
	};
	
	// publish the variable usage to all characterisations
	characterizations->forEach(characterization) {
		characterization.variableUsage_VariableCharacterisation := usage;
	};
	
	return usage;
}